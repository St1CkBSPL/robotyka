#include "NXT++.h"
#include <iostream>
#include <conio.h>
using namespace std;
using namespace NXT;

Comm::NXTComm polaczenieNXT;

//PRZED UŻYCIEM SPRZETU DOKŁADNIE SPRAWDZAMY: 
//DO KTÓRYCH PORTÓW WEJŚCIOWYCH (IN) PODŁĄCZONE SENSORY,
//DO KTÓRYCH PORTÓW WYJŚCIOWYCH (OUT) PODŁĄCZONE SĄ SERVO-MOTORY,
//STARAMY SIĘ PISAC KOD Z MOŻLIWOŚCIĄ ZATRZYMANIA ROBOTA W KAŻDEJ CHWILI,
//ROBOT POWIENIEN BYC PRZEMIESZCZONY W MIEJSCE TESTÓW ZA POŚREDNICTWEM ZDALNEGO STEROWANIA,
//CZUJNIKI SA INICJOWANE PRZED PETLA NIESKONCZONA,
//CZUJNIKI SA DEAKTYWOWANE ZA PETLA NIESKONCZONA, LUB PO KOMENDZIE k,

int przeliczKat(int katZadany, int katAktualny)
{
	katAktualny = katAktualny - katZadany;
	if (katAktualny > 180)
	{
		katAktualny = katAktualny - 360;
	}
	else if (katAktualny < -180)
	{
		katAktualny = 360 + katAktualny;
	}
	return katAktualny;
}

double wzmocnienieP = 1, wzmocnienieD = 0.5;

void sterujRobotem(int mocSilnika1, int mocSilnika2, int katDocelowy, int orientacja)
{
	static int poprzedniBlad = 0;
	int bladAktualny = przeliczKat(katDocelowy, orientacja);
	int roznicaBledu = bladAktualny - poprzedniBlad;
	double korektaPID = wzmocnienieP * bladAktualny + wzmocnienieD * roznicaBledu;
	if (bladAktualny <= 0)
	{
		if (mocSilnika1 + korektaPID > 10)
		{
			mocSilnika2 = 10;
		}
		else if (mocSilnika1 + korektaPID < -10)
		{
			mocSilnika2 = -10;
		}
		else
		{
			mocSilnika2 = mocSilnika1 + korektaPID;
		}
	}
	if (bladAktualny > 0)
	{
		if (mocSilnika2 - korektaPID > 10)
		{
			mocSilnika1 = 10;
		}
		else if (mocSilnika2 - korektaPID < -10)
		{
			mocSilnika1 = -10;
		}
		else
		{
			mocSilnika1 = mocSilnika2 - korektaPID;
		}
	}
	poprzedniBlad = bladAktualny;
	cout << "k1 = " << mocSilnika1 << "; k2 =" << mocSilnika2 << endl;
}


int main()
{
	srand(time(NULL));
	cout << "Szukanie sygnalu... to moze zajac chwile.\n";
	if (NXT::OpenBT(&polaczenieNXT)) //initialize the NXT and continue if it succeeds
	{
		cout << "Sygnal znaleziony!";
		cout << "\nPoziom baterii = " << NXT::BatteryLevel(&polaczenieNXT);
		cout << "\nDostepna pamiec flash = " << NXT::GetAvailableFlash(&polaczenieNXT);
		int predkoscLiniowa = 30;//szybkość jazdy w przód i tył
		int predkoscLiniowaTemp = 30;//potrzebna do sprawdzania czy predkosc sie zmienila

		int predkoscObrotu = 20;//szybkość obrotu w lewo, prawo
		int predkoscObrotuTemp = 20;//potrzebna do sprawdzania czy predkosc sie zmienila

		char ostatniaInstrukcja;//zapamietana ostatnia instrukcja sterująca

		//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		//NXT::Sensor::SetTouch(&polaczenieNXT, IN_1);//inicjacja sensora dotyku

		//aktywacja kompasu,
		NXT::Sensor::SetSonar(&polaczenieNXT, IN_1);
		//aktywacja czujnika koloru
		//NXT::Sensor::SetColor(&polaczenieNXT, IN_2, 'n');
		//int color;

		//aktywacja sonaru,
		//NXT::Sensor::SetSonar(&polaczenieNXT, IN_3);

		//początek programu
		NXT::StartProgram(&polaczenieNXT, "program1");

		//zmienna używana do sterowania
		char wyborUzytkownika;
		cout << "\n ___Podstawowe sterowanie do uzupelnienia___";
		cout << "\n A - jazda w lewo";
		cout << "\n D - jazda w prawo";
		cout << "\n W - jazda na wprost";
		cout << "\n S - jazda do tylu";
		cout << "\n U - odczyt z sonaru";
		cout << "\n C - odczyt nasycenia koloru";
		cout << "\n V - odczyt z kompasu";
		cout << "\n H - Zatrzymanie silnikow";
		cout << "\n P - implementacja kontrolera PID";
		cout << "\n O - implementacja kontrolera PID z relatywnym kompasem";
		cout << "\n X - test kontrolera P";
		cout << "\nK - Koniec Programu";

		do
		{
			//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		/*
		if(NXT::Sensor::GetValue(&polaczenieNXT, IN_1)==1)
			{
			for(int i=1;i<1000;i=i+10)
				{
				NXT::PlayTone(&polaczenieNXT, i, 1);
				Wait(1);
				}
			}
		*/

			if (kbhit() == true)
			{

				wyborUzytkownika = getch();
				if (wyborUzytkownika == 'P' || wyborUzytkownika == 'p')
				{
					int silnikLewy, silnikPrawy, kursZadany = 0, kursAktualny, uchyb, poprzedniUchyb = 0;
					do
					{
						silnikLewy = 30;
						silnikPrawy = 30;
						kursAktualny = 2 * NXT::Sensor::GetSonarValue(&polaczenieNXT, IN_1); // kompas
						NXT::Motor::SetForward(&polaczenieNXT, OUT_C, silnikLewy);
						NXT::Motor::SetForward(&polaczenieNXT, OUT_B, silnikPrawy);
						uchyb = przeliczKat(kursZadany, kursAktualny);
						int zmianaUchybu = uchyb - poprzedniUchyb;
						double sygnalKorekcji = wzmocnienieP * uchyb + wzmocnienieD * zmianaUchybu;
						if (uchyb <= 0)
						{
							if (silnikLewy + sygnalKorekcji > silnikPrawy)
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_B, silnikPrawy);
							}
							else if (silnikLewy + sygnalKorekcji < - silnikPrawy)
							{
								NXT::Motor::SetReverse(&polaczenieNXT, OUT_B, silnikPrawy);
							}
							else
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_B, silnikLewy + sygnalKorekcji);
							}

						}
						if (uchyb > 0)
						{
							if (silnikPrawy - sygnalKorekcji > silnikLewy)
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_C, silnikLewy);
							}
							else if (silnikPrawy - sygnalKorekcji < - silnikLewy)
							{
								NXT::Motor::SetReverse(&polaczenieNXT, OUT_C, silnikLewy);
							}
							else
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_C, silnikPrawy - sygnalKorekcji);
							}
						}
						poprzedniUchyb = uchyb;
						if (kbhit() == true)
						{
							wyborUzytkownika = getch();
							if (wyborUzytkownika == 'K' || wyborUzytkownika == 'k')
							{
								NXT::Motor::Stop(&polaczenieNXT, OUT_B, 0);
								NXT::Motor::Stop(&polaczenieNXT, OUT_C, 0);
								NXT::Motor::Stop(&polaczenieNXT, OUT_A, 0);
								NXT::Sensor::SetSonarOff(&polaczenieNXT, IN_1);
								//NXT::Sensor::SetColorOff(&polaczenieNXT, IN_2);

								break;
							}

							if (wyborUzytkownika == 'N' || wyborUzytkownika == 'n')
							{
								kursZadany = 0;
							}
							if (wyborUzytkownika == 'S' || wyborUzytkownika == 's')
							{
								kursZadany = 180;
							}
							if (wyborUzytkownika == 'E' || wyborUzytkownika == 'e')
							{
								kursZadany = 90;
							}
							if (wyborUzytkownika == 'W' || wyborUzytkownika == 'w')
							{
								kursZadany = 270;
							}

							continue;
						}

					} while (wyborUzytkownika != 'K' && wyborUzytkownika != 'k');
				}
				if (wyborUzytkownika == 'O' || wyborUzytkownika == 'O')
				{
					int punktOdniesienia = 2 * NXT::Sensor::GetSonarValue(&polaczenieNXT, IN_1);
					//kompas
					int mLewy, mPrawy, orientacjaRobot, kursRelatywny = punktOdniesienia, uchybRel, uchybRelPoprzedni = 0;
					do
					{
						mLewy = 30;
						mPrawy = 30;
						orientacjaRobot = 2 * NXT::Sensor::GetSonarValue(&polaczenieNXT, IN_1); // kompas
						NXT::Motor::SetForward(&polaczenieNXT, OUT_C, mLewy);
						NXT::Motor::SetForward(&polaczenieNXT, OUT_B, mPrawy);
						uchybRel = przeliczKat(kursRelatywny, orientacjaRobot);
						int roznicaUchybuRel = uchybRel - uchybRelPoprzedni;
						double korektaRel = wzmocnienieP * uchybRel + wzmocnienieD * roznicaUchybuRel;
						if (uchybRel <= 0)
						{
							if (mLewy + korektaRel > mPrawy)
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_B, mPrawy);
							}
							else if (mLewy + korektaRel < -mPrawy)
							{
								NXT::Motor::SetReverse(&polaczenieNXT, OUT_B, mPrawy);
							}
							else
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_B, mLewy + korektaRel);
							}

						}
						if (uchybRel > 0)
						{
							if (mPrawy - korektaRel > mLewy)
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_C, mLewy);
							}
							else if (mPrawy - korektaRel < -mLewy)
							{
								NXT::Motor::SetReverse(&polaczenieNXT, OUT_C, mLewy);
							}
							else
							{
								NXT::Motor::SetForward(&polaczenieNXT, OUT_C, mPrawy - korektaRel);
							}
						}
						uchybRelPoprzedni = uchybRel;
						if (kbhit() == true)
						{
							wyborUzytkownika = getch();
							if (wyborUzytkownika == 'K' || wyborUzytkownika == 'k')
							{
								NXT::Motor::Stop(&polaczenieNXT, OUT_B, 0);
								NXT::Motor::Stop(&polaczenieNXT, OUT_C, 0);
								NXT::Motor::Stop(&polaczenieNXT, OUT_A, 0);
								NXT::Sensor::SetSonarOff(&polaczenieNXT, IN_1);
								//NXT::Sensor::SetColorOff(&polaczenieNXT, IN_2);

								break;
							}

							if (wyborUzytkownika == 'N' || wyborUzytkownika == 'n')
							{
								kursRelatywny = punktOdniesienia;
							}
							if (wyborUzytkownika == 'S' || wyborUzytkownika == 's')
							{
								kursRelatywny = punktOdniesienia + 180;
							}
							if (wyborUzytkownika == 'E' || wyborUzytkownika == 'e')
							{
								kursRelatywny = punktOdniesienia + 90;
							}
							if (wyborUzytkownika == 'W' || wyborUzytkownika == 'w')
							{
								kursRelatywny = punktOdniesienia + 270;
							}

							continue;
						}

					} while (wyborUzytkownika != 'K' && wyborUzytkownika != 'k');
				}
				if (wyborUzytkownika == 'X' || wyborUzytkownika == 'x')
				{
					for (int i = 0; i < 20; i++)
					{
						sterujRobotem(10, 10, 90, 79 + i);
					}
				}
				if (wyborUzytkownika == 'N' || wyborUzytkownika == 'n')
				{
					predkoscLiniowa -= 10;
				}

				if (wyborUzytkownika == 'M' || wyborUzytkownika == 'm')
				{
					predkoscLiniowa += 10;
				}

				if (wyborUzytkownika == 'V' || wyborUzytkownika == 'v')
				{
					predkoscObrotu--;
				}

				if (wyborUzytkownika == 'B' || wyborUzytkownika == 'b')
				{
					predkoscObrotu++;
				}
				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (wyborUzytkownika == 'A' || wyborUzytkownika == 'a' || (predkoscObrotuTemp != predkoscObrotu && ostatniaInstrukcja == 'a'))
				{
					predkoscObrotuTemp = predkoscObrotu;
					ostatniaInstrukcja = 'a';
					NXT::Motor::SetForward(&polaczenieNXT, OUT_B, predkoscObrotu);
					NXT::Motor::SetReverse(&polaczenieNXT, OUT_C, predkoscObrotu);
					//cout<<"SonarValue = "<<NXT::Sensor::GetSonarValue(&polaczenieNXT, IN_4);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (wyborUzytkownika == 'D' || wyborUzytkownika == 'd' || (predkoscObrotuTemp != predkoscObrotu && ostatniaInstrukcja == 'd'))
				{
					predkoscObrotuTemp = predkoscObrotu;
					ostatniaInstrukcja = 'd';
					NXT::Motor::SetReverse(&polaczenieNXT, OUT_B, predkoscObrotu);
					NXT::Motor::SetForward(&polaczenieNXT, OUT_C, predkoscObrotu);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (wyborUzytkownika == 'W' || wyborUzytkownika == 'w' || (predkoscLiniowaTemp != predkoscLiniowa && ostatniaInstrukcja == 'w'))
				{
					predkoscLiniowaTemp = predkoscLiniowa;
					ostatniaInstrukcja = 'w';
					NXT::Motor::SetForward(&polaczenieNXT, OUT_B, predkoscLiniowa);
					NXT::Motor::SetForward(&polaczenieNXT, OUT_C, predkoscLiniowa);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (wyborUzytkownika == 'S' || wyborUzytkownika == 's' || (predkoscLiniowaTemp != predkoscLiniowa && ostatniaInstrukcja == 's'))
				{
					predkoscLiniowaTemp = predkoscLiniowa;
					ostatniaInstrukcja = 's';
					NXT::Motor::SetReverse(&polaczenieNXT, OUT_B, predkoscLiniowa);
					NXT::Motor::SetReverse(&polaczenieNXT, OUT_C, predkoscLiniowa);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (wyborUzytkownika == 'H' || wyborUzytkownika == 'h')
				{
					NXT::Motor::SetForward(&polaczenieNXT, OUT_B, 0);
					NXT::Motor::SetForward(&polaczenieNXT, OUT_C, 0);
					NXT::Motor::Stop(&polaczenieNXT, OUT_B, 0);
					NXT::Motor::Stop(&polaczenieNXT, OUT_C, 0);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (wyborUzytkownika == 'K' || wyborUzytkownika == 'k')
				{
					NXT::Motor::Stop(&polaczenieNXT, OUT_B, 0);
					NXT::Motor::Stop(&polaczenieNXT, OUT_C, 0);
					NXT::Motor::Stop(&polaczenieNXT, OUT_A, 0);
					NXT::Sensor::SetSonarOff(&polaczenieNXT, IN_1);
					NXT::Sensor::SetColorOff(&polaczenieNXT, IN_2);

					break;
				}

				//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
				//if (wyborUzytkownika == 'U' || wyborUzytkownika == 'u')
				//{
				//	cout << "\n Wskazanie sonaru = " << NXT::Sensor::GetSonarValue(&polaczenieNXT, IN_3);
				//}
				if (wyborUzytkownika == 'V' || wyborUzytkownika == 'v')
				{
					cout << "\n Wskazanie kompasu = " << NXT::Sensor::GetSonarValue(&polaczenieNXT, IN_1);
				}

				//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
				//if (wyborUzytkownika == 'C' || wyborUzytkownika == 'c')
				//{
				//	color = NXT::Sensor::GetValue(&polaczenieNXT, IN_2);
				//	Wait(50);
				//	cout << "\nNasycenie swaitla = " << color;
				//}

				continue;
			}
		} while (wyborUzytkownika != 'k' && wyborUzytkownika != 'K');

		NXT::StopProgram(&polaczenieNXT);
	}
	NXT::Close(&polaczenieNXT); //close communication with NXT

	cout << "\n\nPress ENTER to close program";
	getchar();

	return 0;
}