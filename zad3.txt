#include "NXT++.h"
#include <iostream>
#include <conio.h>
#include <algorithm> // Do funkcji max/min/abs
#include <ctime>

using namespace std;
using namespace NXT;

Comm::NXTComm polaczenie;

// --- PARAMETRY REGULATORA PD ---
double Kp = 1.0; 
double Kd = 0.5; 

// --- FUNKCJE POMOCNICZE ---

// Oblicza najkrótszą drogę obrotu do celu
// Zwraca błąd w zakresie -180 do 180 stopni
int ObliczBladKata(int cel, int aktualny)
{
    int roznica = aktualny - cel;
    
    if (roznica > 180)
    {
        roznica -= 360;
    }
    else if (roznica < -180)
    {
        roznica += 360;
    }
    return roznica;
}

// Funkcja przycinająca wartości mocy silnika do zakresu -100 do 100
int LimitujMoc(int moc)
{
    if (moc > 100) return 100;
    if (moc < -100) return -100;
    return moc;
}

void TestujRegulator(int bazaLewy, int bazaPrawy, int cel, int aktualnyKat)
{
    static int ostatniBlad = 0; 
    
    int blad = ObliczBladKata(cel, aktualnyKat); 
    int deltaBledu = blad - ostatniBlad;
    
    double sygnalSterujacy = (Kp * blad) + (Kd * deltaBledu); 
    
    int wynikLewy = 0;
    int wynikPrawy = 0;
    if (blad <= 0)
    {
        wynikPrawy = LimitujMoc(bazaLewy + (int)sygnalSterujacy);
    }
    else 
    {
        wynikLewy = LimitujMoc(bazaPrawy - (int)sygnalSterujacy);
    }
    
    ostatniBlad = blad; 
    cout << "Moc L: " << wynikLewy << " | Moc P: " << wynikPrawy << endl;
}

int main()
{
    srand(time(NULL));
    cout << "[SYSTEM] Nawiazywanie polaczenia z robotem...\n";
    
    if (NXT::OpenBT(&polaczenie))
    {
        cout << "[SUKCES] Polaczono z NXT!";
        cout << "\nBateria: " << NXT::BatteryLevel(&polaczenie) << "mV"; 
        
        // Zmienne sterowania manualnego
        int predkoscJazdy = 30; 
        int predkoscObrotu = 20;
        int tempJazda = 30;
        int tempObrot = 20;
        char ostatniRuch;
        NXT::Sensor::SetSonar(&polaczenie, IN_1); // Kompas/Sonar na porcie 1 [cite: 13]
        NXT::StartProgram(&polaczenie, "program1");

        char klawisz;
        cout << "\n\n=== PANEL STEROWANIA ===";
        cout << "\n WSAD - Sterowanie manualne";
        cout << "\n P - Automatyczna stabilizacja kursu (PID)";
        cout << "\n O - Stabilizacja wzgledem startu (PID Relatywny)";
        cout << "\n K - Zakoncz"; 

        do
        {
            if (kbhit())
            {
                klawisz = getch();

                // --- TRYB PID (Stabilizacja Kursu) ---
                if (klawisz == 'P' || klawisz == 'p')
                {
                    int mocBazowaL = 30, mocBazowaP = 30;
                    int celKata = 0;
                    int aktualnyKat, blad;
                    int poprzedniBlad = 0; 

                    cout << "\n[TRYB PID] Utrzymywanie kursu: " << celKata;

                    do {
                        aktualnyKat = 2 * NXT::Sensor::GetSonarValue(&polaczenie, IN_1);
                        
                        NXT::Motor::SetForward(&polaczenie, OUT_C, mocBazowaL);
                        NXT::Motor::SetForward(&polaczenie, OUT_B, mocBazowaP);

                        // --- ALGORYTM PID ---
                        blad = ObliczBladKata(celKata, aktualnyKat); 
                        int delta = blad - poprzedniBlad;            
                        double korekta = (Kp * blad) + (Kd * delta);


                        if (blad <= 0) 
                        {
                            int nowaMocB = mocBazowaL + (int)korekta;
                            
                            if (nowaMocB > mocBazowaP) NXT::Motor::SetForward(&polaczenie, OUT_B, mocBazowaP); 
                            else if (nowaMocB < -mocBazowaP) NXT::Motor::SetReverse(&polaczenie, OUT_B, mocBazowaP); 
                            else NXT::Motor::SetForward(&polaczenie, OUT_B, nowaMocB);
                        }
                        else // blad > 0
                        {
                            int nowaMocC = mocBazowaP - (int)korekta;

                            if (nowaMocC > mocBazowaL) NXT::Motor::SetForward(&polaczenie, OUT_C, mocBazowaL); 
                            else if (nowaMocC < -mocBazowaL) NXT::Motor::SetReverse(&polaczenie, OUT_C, mocBazowaL);
                            else NXT::Motor::SetForward(&polaczenie, OUT_C, nowaMocC);
                        }

                        poprzedniBlad = blad;

                        // Obsługa zmiany celu w locie (N, S, E, W)
                        if (kbhit())
                        {
                            char subDecyzja = getch();
                            if (subDecyzja == 'K' || subDecyzja == 'k') {
                                NXT::Motor::Stop(&polaczenie, OUT_B, 0);
                                NXT::Motor::Stop(&polaczenie, OUT_C, 0);
                                break; 
                            }
                            // Zmiana kierunku
                            if (subDecyzja == 'N' || subDecyzja == 'n') celKata = 0;  
                            if (subDecyzja == 'S' || subDecyzja == 's') celKata = 180; 
                            if (subDecyzja == 'E' || subDecyzja == 'e') celKata = 90;  
                            if (subDecyzja == 'W' || subDecyzja == 'w') celKata = 270;
                        }
                    } while (true);
                }

                // --- TRYB PID RELATYWNY (O) ---
                if (klawisz == 'O' || klawisz == 'o')
                {
                    // Pobierz początkowy kąt jako cel
                    int startowyKat = 2 * NXT::Sensor::GetSonarValue(&polaczenie, IN_1);
                    int celRelatywny = startowyKat;
                    cout << "\n[TRYB O] Zablokowano kurs na: " << celRelatywny;
                }

                // --- STEROWANIE MANUALNE ---
                if (klawisz == 'W' || klawisz == 'w') {
                    NXT::Motor::SetForward(&polaczenie, OUT_B, predkoscJazdy);
                    NXT::Motor::SetForward(&polaczenie, OUT_C, predkoscJazdy);
                }
                if (klawisz == 'S' || klawisz == 's') {
                    NXT::Motor::SetReverse(&polaczenie, OUT_B, predkoscJazdy);
                    NXT::Motor::SetReverse(&polaczenie, OUT_C, predkoscJazdy);
                }
                if (klawisz == 'A' || klawisz == 'a') {
                    NXT::Motor::SetForward(&polaczenie, OUT_B, predkoscObrotu);
                    NXT::Motor::SetReverse(&polaczenie, OUT_C, predkoscObrotu);
                }
                if (klawisz == 'D' || klawisz == 'd') {
                    NXT::Motor::SetReverse(&polaczenie, OUT_B, predkoscObrotu);
                    NXT::Motor::SetForward(&polaczenie, OUT_C, predkoscObrotu);
                }
                if (klawisz == 'H' || klawisz == 'h') { // Hamulec
                    NXT::Motor::Stop(&polaczenie, OUT_B, 1); // 1 = brake mode
                    NXT::Motor::Stop(&polaczenie, OUT_C, 1);
                }

                // Zmiana prędkości manualnej
                if (klawisz == 'N') predkoscJazdy -= 10;
                if (klawisz == 'M') predkoscJazdy += 10;
            }

        } while (klawisz != 'k' && klawisz != 'K');

        NXT::StopProgram(&polaczenie);
        NXT::Close(&polaczenie);
    }
    else {
        cout << "Blad polaczenia z robotem!";
    }

    return 0;
}